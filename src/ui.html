<h1>Fitmap</h1>
<canvas id="canvas" width="300" height="100" style="display:none"></canvas>
<button type="button" name="button" onclick="rasterizeSelection()">Rasterize</button>
<button type="button" name="button"onclick="closePlugin()">Cancel</button>
<script>

  function closePlugin() {
    let data = {
      type: 'CLOSE'
    }
    window.parent.postMessage({pluginMessage: data}, '*')
  }

  function rasterizeSelection() {
    let data = {
      type: 'RASTERIZE',
      flatten: false,
      roundSize: false,
      roundPosition: true,
      roundPaths: false
    }
    console.log('send rasterize command')
    window.parent.postMessage({pluginMessage: data}, '*')
  }

  window.onmessage = async (event) => {

    if (event.data.pluginMessage == "initialize") {
      console.log("initialize!")
    } else {
      let pathData = event.data.pluginMessage

      const canvas = document.getElementById('canvas')
      const context = canvas.getContext('2d')

      context.webkitImageSmoothingEnabled = false
      context.mozImageSmoothingEnabled = false
      context.imageSmoothingEnabled = false

      const pathValues = Object.values(pathData.paths)

      canvas.width = pathData.width
      canvas.height = pathData.height

      let fillRGB
      let fillHex
      if (pathData.fill.length > 0) {
        fillRGB = pathData.fill[0].color
        for (var component in fillRGB) {
          if (fillRGB.hasOwnProperty(component)) {
            fillRGB[component] *= 255;
          }
        }
        fillHex = rgbToHex(Math.round(fillRGB.r), Math.round(fillRGB.g), Math.round(fillRGB.b))
      }

      let strokeRGB
      let strokeHex
      if (pathData.strokes.length > 0) {
        strokeRGB = pathData.strokes[0].color
        for (var component in strokeRGB) {
          if (strokeRGB.hasOwnProperty(component)) {
            strokeRGB[component] *= 255;
          }
        }
        strokeHex = rgbToHex(Math.round(strokeRGB.r), Math.round(strokeRGB.g), Math.round(strokeRGB.b))
      }

      let strokeColor, strokewidth
      if (pathData.strokes.length > 0) {
        strokeColor = strokeHex
        strokewidth = (pathData.strokeAlign === 'CENTER') ? pathData.strokeWeight : pathData.strokeWeight * 2
      } else {
        strokeColor = '#000'
        strokewidth = 0
      }

      if (pathData.strokes.length > 0 && pathData.strokeWeight > 0) {
        if (pathData.strokeAlign === 'CENTER' || pathData.strokeAlign === 'INSIDE' ) {
          context.translate(pathData.strokeWeight/2, pathData.strokeWeight/2);
        }
      }

      let pathBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let fillBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let strokeBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let sumBitmap = context.getImageData(0, 0, pathData.width, pathData.height)

      let pathPixels = []
      let fillPixels = []
      let strokePixels = []

      for (const value of pathValues) {
        let currentPath = new Path2D(value.data)
        if (pathData.strokeAlign === 'INSIDE' ) {
          context.clip(currentPath)
        }

        if (pathData.fill.length > 0) {
          context.clearRect(0, 0, pathData.width, pathData.height)
          context.fillStyle = fillHex
          context.fill(currentPath, value.windingRule.toLowerCase())

          fillBitmap = context.getImageData(0, 0, pathData.width, pathData.height)

          fillPixels = fillBitmap.data

          for (let i = 0; i < fillPixels.length; i += 4) {
            fillPixels[i + 0] = Math.round(fillRGB.r)
            fillPixels[i + 1] = Math.round(fillRGB.g)
            fillPixels[i + 2] = Math.round(fillRGB.b)
            if (fillPixels[i + 3] > 127) {
              fillPixels[i + 3] = 255
            } else {
              fillPixels[i + 3] = 0
            }
          }

          fillBitmap = new ImageData(fillPixels, pathData.width, pathData.height)

        }

        if (pathData.strokes.length > 0 && pathData.strokeWeight > 0) {
          context.clearRect(0, 0, pathData.width, pathData.height);
          context.strokeStyle = strokeColor
          context.lineWidth = strokewidth
          context.stroke(currentPath)

          strokeBitmap = context.getImageData(0, 0, pathData.width, pathData.height)

          strokePixels = strokeBitmap.data

          for (let i = 0; i < strokePixels.length; i += 4) {
            strokePixels[i + 0] = Math.round(strokeRGB.r)
            strokePixels[i + 1] = Math.round(strokeRGB.g)
            strokePixels[i + 2] = Math.round(strokeRGB.b)
            if (strokePixels[i + 3] > 127) {
              strokePixels[i + 3] = 255
            } else {
              strokePixels[i + 3] = 0
            }
          }

          console.log(strokePixels)

          //let fillPixels = fillBitmap.data

          strokeBitmap = new ImageData(strokePixels, pathData.width, pathData.height)

        }

        let pathPixels = pathBitmap.data

        for (let i = 0; i < pathPixels.length; i += 4) {
          if (fillPixels[i + 3] > 0 || strokePixels[i + 3] > 0) {
            if (fillPixels[i + 3] > 0 && strokePixels[i + 3] > 0) {
              pathPixels[i + 0] = strokePixels[i + 0]
              pathPixels[i + 1] = strokePixels[i + 1]
              pathPixels[i + 2] = strokePixels[i + 2]
              pathPixels[i + 3] = 255
            } else {
              if (fillPixels[i + 3] > 0) {
                pathPixels[i + 0] = fillPixels[i + 0]
                pathPixels[i + 1] = fillPixels[i + 1]
                pathPixels[i + 2] = fillPixels[i + 2]
                pathPixels[i + 3] = 255
              } else {
                pathPixels[i + 0] = strokePixels[i + 0]
                pathPixels[i + 1] = strokePixels[i + 1]
                pathPixels[i + 2] = strokePixels[i + 2]
                pathPixels[i + 3] = 255
              }
            }
          } else {
            pathPixels[i + 0] = 0
            pathPixels[i + 1] = 0
            pathPixels[i + 2] = 0
            pathPixels[i + 3] = 0
          }
        }

        sumBitmap = new ImageData(pathPixels, pathData.width, pathData.height)

        //pathBitmap = fillBitmap
        //pathBitmap = strokeBitmap
        pathBitmap = sumBitmap


      }

      const newBytes = await encode(canvas, context, pathBitmap)

      let data = {
        type: 'REPLACE',
        bitmapData: newBytes
      }

      window.parent.postMessage({pluginMessage: data}, '*')
    }
  }

  function componentToHex(c) {
    let hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }

  function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }

  async function encode(canvas, ctx, imageData) {
    ctx.putImageData(imageData, 0, 0)

    return await new Promise((resolve, reject) => {
      canvas.toBlob(blob => {
        const reader = new FileReader()
        reader.onload = () => resolve(new Uint8Array(reader.result))
        reader.onerror = () => reject(new Error('Could not read from blob'))
        reader.readAsArrayBuffer(blob)
      })
    })
  }

</script>
