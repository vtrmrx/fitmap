<div id="react-page"></div>
<canvas id="canvas" width="300" height="100" style="display:none"></canvas>
<script>

  function closePlugin() {
    let data = {
      type: 'CLOSE'
    }
    window.parent.postMessage({pluginMessage: data}, '*')
  }

  function rasterizeSelection() {
    let data = {
      type: 'RASTERIZE',
      flatten: false,
      roundSize: false,
      roundPosition: true,
      roundPaths: false
    }
    console.log('send rasterize command')
    window.parent.postMessage({pluginMessage: data}, '*')
  }

  window.onmessage = async (event) => {

    if (event.data.pluginMessage == "initialize") {
      console.log("initialize!")
    } else {
      let pathData = event.data.pluginMessage

      const canvas = document.getElementById('canvas')
      const context = canvas.getContext('2d')

      context.webkitImageSmoothingEnabled = false
      context.mozImageSmoothingEnabled = false
      context.imageSmoothingEnabled = false

      const pathValues = Object.values(pathData.paths)

      canvas.width = pathData.width
      canvas.height = pathData.height

      let fillRGB
      let fillHex
      if (pathData.fill.length > 0) {
        fillRGB = pathData.fill[0].color
        for (var component in fillRGB) {
          if (fillRGB.hasOwnProperty(component)) {
            fillRGB[component] *= 255;
          }
        }
        fillHex = rgbToHex(Math.round(fillRGB.r), Math.round(fillRGB.g), Math.round(fillRGB.b))
      } else {

        fillHex = '#000000'
        fillRGB = hexToRgb(fillHex)

      }

      let strokeRGB, strokeHex, strokeWidth
      if (pathData.strokes.length > 0 && pathData.strokeWeight > 0) {

        strokeRGB = pathData.strokes[0].color
        for (var component in strokeRGB) {
          if (strokeRGB.hasOwnProperty(component)) {
            strokeRGB[component] *= 255;
          }
        }
        strokeHex = rgbToHex(Math.round(strokeRGB.r), Math.round(strokeRGB.g), Math.round(strokeRGB.b))
        strokewidth = (pathData.strokeAlign === 'CENTER') ? pathData.strokeWeight : pathData.strokeWeight * 2

        if (pathData.strokeAlign === 'CENTER' || pathData.strokeAlign === 'INSIDE' ) {
          context.translate(pathData.strokeWeight/2, pathData.strokeWeight/2)
        }

      } else {

        strokeHex = '#000000'
        strokeRGB = hexToRgb(strokeHex)
        strokewidth = 0

      }

      let pathBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let fillBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let strokeBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
      let sumBitmap = context.getImageData(0, 0, pathData.width, pathData.height)

      let pathPixels = []
      let fillPixels = []
      let strokePixels = []

      if (pathData.fill.length > 0) {

        context.clearRect(0, 0, pathData.width, pathData.height)
        context.fillStyle = fillHex

        for (const value of pathValues) {
          let currentPath = new Path2D(value.data)
          context.fill(currentPath, value.windingRule.toLowerCase())
        }

        fillBitmap = context.getImageData(0, 0, pathData.width, pathData.height)

        fillPixels = removeAlpha(fillBitmap.data)

        fillBitmap = new ImageData(fillPixels, pathData.width, pathData.height)

      } else {
        fillBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
        fillPixels = fillBitmap.data
        for (let i = 0; i < fillPixels.length; i += 4) {
          fillPixels[i + 3] = 0
        }
        console.log(fillPixels)
        fillBitmap = new ImageData(fillPixels, pathData.width, pathData.height)
      }

      if (pathData.strokes.length > 0 && pathData.strokeWeight > 0) {

        context.clearRect(0, 0, pathData.width, pathData.height);
        context.strokeStyle = strokeHex
        context.lineWidth = strokewidth

        for (const value of pathValues) {
          let currentPath = new Path2D(value.data)
          if (pathData.strokeAlign === 'INSIDE' ) {
            context.clip(currentPath)
          }
          context.stroke(currentPath)
        }

        strokeBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
        strokePixels = removeAlpha(strokeBitmap.data)
        strokeBitmap = new ImageData(strokePixels, pathData.width, pathData.height)

      } else {
        strokeBitmap = context.getImageData(0, 0, pathData.width, pathData.height)
        strokePixels = strokeBitmap.data
        for (let i = 0; i < strokePixels.length; i += 4) {
          strokePixels[i + 3] = 0
        }
        strokeBitmap = new ImageData(strokePixels, pathData.width, pathData.height)
      }

      pathPixels = pathBitmap.data

      //let pathPixels = alphaComposite(pathBitmap.data, fillPixels, strokePixels, fillHex, strokeHex)

      for (let i = 0; i < pathPixels.length; i += 4) {

        let fillAlpha = fillPixels[i + 3] / 255
        let fillRedAlpha = hexToRgb(fillHex).r * fillAlpha
        let fillGreenAlpha = hexToRgb(fillHex).g * fillAlpha
        let fillBlueAlpha = hexToRgb(fillHex).b * fillAlpha

        let strokeAlpha = strokePixels[i + 3] / 255
        let strokeRedAlpha = hexToRgb(strokeHex).r * strokeAlpha
        let strokeGreenAlpha = hexToRgb(strokeHex).g * strokeAlpha
        let strokeBlueAlpha = hexToRgb(strokeHex.b) * strokeAlpha

        let finalRed = strokeRedAlpha + fillRedAlpha * (1 - strokeAlpha)
        let finalGreen = strokeGreenAlpha + fillGreenAlpha * (1 - strokeAlpha)
        let finalBlue = strokeBlueAlpha + fillBlueAlpha * (1 - strokeAlpha)

        let finalAlpha = (fillAlpha + strokeAlpha - fillAlpha * strokeAlpha) * 255

        console.log('f: ' + finalRed + ' g: ' + finalGreen + ' b: ' + finalBlue + ' a: ' + finalAlpha)

        pathPixels[i + 0] = finalRed
        pathPixels[i + 1] = finalGreen
        pathPixels[i + 2] = finalBlue
        pathPixels[i + 3] = finalAlpha

      }

      sumBitmap = new ImageData(pathPixels, pathData.width, pathData.height)

      pathBitmap = sumBitmap

      const newBytes = await encode(canvas, context, pathBitmap)

      let data = {
        type: 'REPLACE',
        bitmapData: newBytes
      }

      window.parent.postMessage({pluginMessage: data}, '*')
    }
  }

  function componentToHex(c) {
    let hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }

  function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }

  function hexToRgb(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null
  }

  function removeAlpha(bitmapData) {
    let pixels = bitmapData
    for (let i = 0; i < pixels.length; i += 4) {
      pixels[i + 0] = bitmapData[i + 0]
      pixels[i + 1] = bitmapData[i + 1]
      pixels[i + 2] = bitmapData[i + 2]
      if (bitmapData[i + 3] >= 127) {
        pixels[i + 3] = 255
      } else {
        pixels[i + 3] = 0
      }
    }
    return pixels
  }

  async function encode(canvas, ctx, imageData) {
    ctx.putImageData(imageData, 0, 0)

    return await new Promise((resolve, reject) => {
      canvas.toBlob(blob => {
        const reader = new FileReader()
        reader.onload = () => resolve(new Uint8Array(reader.result))
        reader.onerror = () => reject(new Error('Could not read from blob'))
        reader.readAsArrayBuffer(blob)
      })
    })
  }

</script>
